####################################################################################################
#####                              TX Ultimate Easy for ESPHome                                #####
#####                  Repository: https://github.com/edwardtfn/TX-Ultimate-Easy               #####
####################################################################################################
##### Purpose: ESPHome - Addon - Cover (Time-based roller shutter using 2 relays)              #####
####################################################################################################
##### Author: Generated by assistant (user requested cover mode)                              #####
####################################################################################################
##### NOTE:                                                                                    #####
##### - This addon expects exactly 2 relays (gang_count == 2) for OPEN / CLOSE.                #####
##### - Relays used: sw_relay_1 (OPEN) and sw_relay_2 (CLOSE).                                 #####
##### - Add this file to the main config via packages if not already included.                #####
##### - Durations are time-based; calibrate using actual travel times of your shutter.         #####
####################################################################################################
---
substitutions:
  ENABLE_COVER_MODE: 'true'
  COVER_NAME: 'Roller Shutter'
  COVER_OPEN_DURATION: 25s      # Adjust to your real open time
  COVER_CLOSE_DURATION: 25s     # Adjust to your real close time
  COVER_LED_COLOR_OPEN: '{0,255,0}'      # RGB when open portion
  COVER_LED_COLOR_CLOSE: '{255,0,0}'     # RGB when closed portion
  COVER_LED_BRIGHTNESS: '0.6'            # Brightness for progress bar
  COVER_LED_UPDATE_INTERVAL: 500ms       # Refresh rate
  COVER_CALIBRATION_MIN_DURATION_MS: '3000' # Minimal plausible full travel time to accept measurement

globals:
  # Persistent pseudo-position (0.0 closed .. 1.0 open)
  - id: cover_pos_saved
    type: float
    restore_value: true
    initial_value: '0.0'
  # Last operation start time (millis)
  - id: cover_last_operation_start
    type: uint32_t
    restore_value: false
    initial_value: '0'
  # Measured durations (ms) - restored for LED scaling
  - id: cover_open_duration_measured
    type: uint32_t
    restore_value: true
    initial_value: '0'
  - id: cover_close_duration_measured
    type: uint32_t
    restore_value: true
    initial_value: '0'
  # Color arrays for LED bar (converted from substitutions)
  - id: cover_led_color_open
    type: int [3]
    restore_value: false
    initial_value: ${COVER_LED_COLOR_OPEN}
  - id: cover_led_color_close
    type: int [3]
    restore_value: false
    initial_value: ${COVER_LED_COLOR_CLOSE}

esphome:
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Restore pseudo-position into cover entity
          float p = id(cover_pos_saved);
          if (p < 0.0f) p = 0.0f; if (p > 1.0f) p = 1.0f;
          id(cover_roller).position = p;
          id(cover_roller).publish_state();
      - script.execute: cover_led_refresh

# Template Cover (ersetzt time_based)
cover:
  - platform: template
    id: cover_roller
    name: ${COVER_NAME}
    optimistic: true
    lambda: |-
      return id(cover_pos_saved);
    open_action:
      - script.execute: cover_open
    close_action:
      - script.execute: cover_close
    stop_action:
      - script.execute: cover_stop

script:
  # Basic relay driving scripts
  - id: cover_open
    mode: restart
    then:
      - switch.turn_on: sw_relay_1
      - switch.turn_off: sw_relay_2
      - lambda: |-
          id(cover_last_operation_start) = millis();
      - script.execute: cover_calibration_mark_start
  - id: cover_close
    mode: restart
    then:
      - switch.turn_on: sw_relay_2
      - switch.turn_off: sw_relay_1
      - lambda: |-
          id(cover_last_operation_start) = millis();
      - script.execute: cover_calibration_mark_start
  - id: cover_stop
    mode: restart
    then:
      - switch.turn_off: sw_relay_1
      - switch.turn_off: sw_relay_2
      - script.execute: cover_calibration_attempt_end

  # Toggle style actions: Start/Stop
  - id: cover_open_action
    mode: restart
    then:
      - lambda: |-
          if (id(cover_roller).current_operation == COVER_OPERATION_IDLE) {
            id(cover_roller).make_call().set_command_open().perform();
          } else {
            id(cover_roller).make_call().set_command_stop().perform();
            // If we stop mid-travel, attempt calibration end using partial (ignored if not full)
            id(cover_calibration_attempt_end)->execute();
          }
      - script.execute: cover_led_refresh
      - script.execute: cover_led_poll
      - lambda: |-
          // If transition started, mark start time
          if (id(cover_roller).current_operation != COVER_OPERATION_IDLE)
            id(cover_last_operation_start) = millis();
      - script.execute: cover_calibration_mark_start
  - id: cover_close_action
    mode: restart
    then:
      - lambda: |-
          if (id(cover_roller).current_operation == COVER_OPERATION_IDLE) {
            id(cover_roller).make_call().set_command_close().perform();
          } else {
            id(cover_roller).make_call().set_command_stop().perform();
          }
      - script.execute: cover_led_refresh
      - script.execute: cover_led_poll
      - lambda: |-
          if (id(cover_roller).current_operation != COVER_OPERATION_IDLE)
            id(cover_last_operation_start) = millis();
      - script.execute: cover_calibration_mark_start

  # Optional: could be extended later for LED progress indication

# Extend touch handling to trigger cover actions using 2 button areas (left=open, right=close)
# Uses touch_on_press script (parameters: button, position). Position range 0..${TOUCH_POSITION_MAX_VALUE} (from core touch package).
  - id: !extend touch_on_press
    then:
      - lambda: |-
          ESP_LOGD("cover.touch", "touch_on_press: position=%u gang_count=%u enable_subst='${ENABLE_COVER_MODE}'", position, id(gang_count));
      - if:
          condition:
            lambda: |-
              // ENABLE_COVER_MODE ist eine Substitution (String), direkte Pointer-Vergleiche vermeiden.
              // Wir interpretieren jeden Wert != 'false' als aktiv.
              const char* enabled = "${ENABLE_COVER_MODE}"; // wird zur Compilezeit ersetzt
              bool cover_enabled = !(strcmp(enabled, "false") == 0 || strcmp(enabled, "0") == 0);
              return cover_enabled && id(gang_count) == 2;
          then:
            - if:
                condition:
                  lambda: 'return position <= (${TOUCH_POSITION_MAX_VALUE} / 2);'
                then:
                  - script.execute: cover_open_action
                else:
                  - script.execute: cover_close_action
            - script.execute: cover_led_refresh
        else:
          - lambda: |-
              ESP_LOGD("cover.touch", "Cover gating condition FALSE (cover_enabled or gang_count mismatch). No action.");

  # LED progress refresh (EU format only currently) - lights up right side proportionally.
  - id: cover_led_refresh
    mode: restart
    then:
      - lambda: |-
          // Determine model format to choose appropriate light partition.
          // We assume EU format uses light_eu_right segment similar to right side indicator.
          // Fallback: use full light if segment not available.
          float pos = id(cover_pos_saved); // 0.0 closed, 1.0 open
          const int total_pixels = 8;
          // Farben aus Globals
          uint8_t r_open = (uint8_t) id(cover_led_color_open)[0];
          uint8_t g_open = (uint8_t) id(cover_led_color_open)[1];
          uint8_t b_open = (uint8_t) id(cover_led_color_open)[2];
          uint8_t r_close = (uint8_t) id(cover_led_color_close)[0];
          uint8_t g_close = (uint8_t) id(cover_led_color_close)[1];
          uint8_t b_close = (uint8_t) id(cover_led_color_close)[2];

          // Gradient Logik: Jeder Pixel bekommt Anteil 'fill' in Abhängigkeit davon, wie weit die Öffnung über seinen Index hinaus geht.
          // coverage = wie viele Pixel wären bei harter Darstellung vollständig "offen".
          float coverage = pos * total_pixels; // z.B. 2.3 bedeutet Pixel 0 und 1 voll offen, Pixel 2 teil-offen

          for (int i=0;i<total_pixels;i++) {
            // fill: 0.0 (geschlossen Farbe) .. 1.0 (geöffnete Farbe), mit fließendem Übergang im Übergangspixel
            float fill = coverage - i; // Anteil über Pixelgrenze hinaus
            if (fill < 0.0f) fill = 0.0f;
            if (fill > 1.0f) fill = 1.0f;
            // Interpolation zwischen geschlossen und offen
            float r = r_close + (r_open - r_close) * fill;
            float g = g_close + (g_open - g_close) * fill;
            float b = b_close + (b_open - b_close) * fill;

            light::LightState* target = nullptr;
            switch(i){
          case 0: target = id(light_27); break;
          case 1: target = id(light_26); break;
          case 2: target = id(light_25); break;
          case 3: target = id(light_24); break;
          case 4: target = id(light_23); break;
          case 5: target = id(light_22); break;
          case 6: target = id(light_21); break;
          case 7: target = id(light_20); break;
            }
            if (!target) continue;
            auto c = target->make_call();
            c.set_rgb(r/255.0f,g/255.0f,b/255.0f).set_brightness(${COVER_LED_BRIGHTNESS});
            c.perform();
          }

  # Bewegungsschleife statt altem Polling
  - id: cover_motion_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              return id(cover_motion_direction) != 0;
          then:
            - lambda: |-
                uint32_t now = millis();
                uint32_t elapsed = now - id(cover_last_operation_start);
                uint32_t duration = (id(cover_motion_direction) == 1)
                                   ? (id(cover_open_duration_measured) != 0 ? id(cover_open_duration_measured) : 25000)
                                   : (id(cover_close_duration_measured) != 0 ? id(cover_close_duration_measured) : 25000);
                float progress = (float) elapsed / (float) duration;
                if (progress > 1.0f) progress = 1.0f;
                if (id(cover_motion_direction) == 1) {
                  id(cover_pos_saved) = progress;
                } else if (id(cover_motion_direction) == -1) {
                  id(cover_pos_saved) = 1.0f - progress;
                }
                id(cover_roller).position = id(cover_pos_saved);
                id(cover_roller).publish_state();
                if (progress >= 1.0f) id(cover_motion_direction) = 0;
            - script.execute: cover_led_refresh
            - delay: ${COVER_LED_UPDATE_INTERVAL}
      - script.execute: cover_calibration_attempt_end

  # Mark start of potential full-travel calibration
  - id: cover_calibration_mark_start
    mode: restart
    then:
      - lambda: |-
          // Only mark if operation active (open or close)
          if (id(cover_roller).current_operation != COVER_OPERATION_IDLE) {
            // position at start
            // Nothing else needed here yet
          }

  # Attempt calibration end: called on stop or after polling loop ends
  - id: cover_calibration_attempt_end
    mode: restart
    then:
      - lambda: |-
          if (id(cover_last_operation_start) == 0) return; // No start recorded
          uint32_t elapsed = millis() - id(cover_last_operation_start);
          // Determine if movement was full (near extremes)
          float pos = id(cover_roller).position;
          bool at_open_end = pos > 0.97f; // tolerance
          bool at_close_end = pos < 0.03f;
          if (elapsed < ${COVER_CALIBRATION_MIN_DURATION_MS}) {
            // too short to be full travel (ignore)
            id(cover_last_operation_start) = 0;
            return;
          }
          if (at_open_end) {
            id(cover_open_duration_measured) = elapsed;
            ESP_LOGI("cover.calibration", "Calibrated OPEN duration: %u ms", (unsigned) elapsed);
          } else if (at_close_end) {
            id(cover_close_duration_measured) = elapsed;
            ESP_LOGI("cover.calibration", "Calibrated CLOSE duration: %u ms", (unsigned) elapsed);
          }
          // Save pseudo-position persistently
          id(cover_pos_saved) = pos;
          id(cover_last_operation_start) = 0;
      - script.execute: cover_led_refresh

# (Release handling could be added similarly if desired)

####################################################################################################
# To enable: add this file under packages in your main config:
# packages:
#   core:     !include TX-Ultimate-Easy-ESPHome_core.yaml
#   standard: !include TX-Ultimate-Easy-ESPHome_standard.yaml
#   cover:    !include TX-Ultimate-Easy-ESPHome_addon_cover.yaml
####################################################################################################
